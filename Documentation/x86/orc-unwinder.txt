Orc unwinder debuginfo generation
=====================================

Overview
--------

The kernel CONFIG_ORC_UNWINDER option enables objtool generation of orc
debuginfo, which is out-of-band data which is used by the in-kernel orc
unwinder.  It's similar in concept to DWARF CFI debuginfo which would be
used by a DWARF unwinder.  The difference is that the format of the orc
data is simpler than DWARF, which in turn allows the unwinder to be
simpler and faster.

Objtool generates the orc data by first doing compile-time stack
metadata validation (CONFIG_STACK_VALIDATION).  After analyzing all the
code paths of a .o file, it determines information about the stack state
at each instruction address in the file and outputs that information to
the .orc_unwind and .orc_unwind_ip sections.

The orc sections are combined at link time and are sorted at boot time.
The unwinder uses the resulting data to correlate instruction addresses
with their stack states at run time.


Orc vs frame pointers
-------------------------

With frame pointers enabled, GCC adds instrumentation code to every
function in the kernel.  The kernel's .text size increases by about
3.2%, resulting in a broad kernel-wide slowdown.  Measurements by Mel
Gorman [1] have shown a slowdown of 5-10% for some workloads.

In contrast, the orc unwinder has no effect on text size or runtime
performance, because the debuginfo is out of band.  So if you disable
frame pointers and enable the orc unwinder, you get a nice performance
improvement across the board, and still have reliable stack traces.

Ingo Molnar says:

  "Note that it's not just a performance improvement, but also an
  instruction cache locality improvement: 3.2% .text savings almost
  directly transform into a similarly sized reduction in cache
  footprint. That can transform to even higher speedups for workloads
  whose cache locality is borderline."

Another benefit of orc compared to frame pointers is that it can
reliably unwind across interrupts and exceptions.  Frame pointer based
unwinds can skip the caller of the interrupted function if it was a leaf
function or if the interrupt hit before the frame pointer was saved.

The main disadvantage of the orc unwinder compared to frame pointers is
that it needs more memory to store the orc unwind tables: roughly 2-4MB
depending on the kernel config.


Orc vs DWARF
------------

Orc debuginfo's advantage over DWARF itself is that it's much simpler.
It gets rid of the complex DWARF CFI state machine and also gets rid of
the tracking of unnecessary registers.  This allows the unwinder to be
much simpler, meaning fewer bugs, which is especially important for
mission critical oops code.

The simpler debuginfo format also enables the unwinder to be much faster
than DWARF, which is important for perf and lockdep.  In a basic
performance test by Jiri Slaby [2], the orc unwinder was about 20x
faster than an out-of-tree DWARF unwinder.  (Note: that measurement was
taken before some performance tweaks were implemented which doubled
performance, so the speedup over DWARF may be closer to 40x.)

The orc data format does have a few downsides compared to DWARF.  The
orc unwind tables take up ~2MB more memory than an DWARF .eh_frame
table.

Another potential downside is that, as GCC evolves, it's conceivable
that the orc data may end up being *too* simple to describe the state of
the stack for certain optimizations.  But IMO this is unlikely because
GCC saves the frame pointer for any unusual stack adjustments it does,
so I suspect we'll really only ever need to keep track of the stack
pointer and the frame pointer between call frames.  But even if we do
end up having to track all the registers DWARF tracks, at least we will
still be able to control the format, e.g.  no complex state machines.


Orc debuginfo generation
------------------------

The orc data is generated by objtool.  With the existing compile-time
stack metadata validation feature, objtool already follows all code
paths, and so it already has all the information it needs to be able to
generate orc data from scratch.  So it's an easy step to go from stack
validation to orc data generation.

It should be possible to instead generate the orc data with a simple
tool which converts DWARF to orc data.  However, such a solution would
be incomplete due to the kernel's extensive use of asm, inline asm, and
special sections like exception tables.

That could be rectified by manually annotating those special code paths
using GNU assembler .cfi annotations in .S files, and homegrown
annotations for inline asm in .c files.  But asm annotations were tried
in the past and were found to be unmaintainable.  They were often
incorrect/incomplete and made the code harder to read and keep updated.
And based on looking at glibc code, annotating inline asm in .c files
might be even worse.

Objtool still needs a few annotations, but only in code which does
unusual things to the stack like entry code.  And even then, far fewer
annotations are needed than what DWARF would need, so they're much more
maintainable than DWARF CFI annotations.

So the advantages of using objtool to generate orc data are that it
gives more accurate debuginfo, with very few annotations.  It also
insulates the kernel from toolchain bugs which can be very painful to
deal with in the kernel since we often have to workaround issues in
older versions of the toolchain for years.

The downside is that the unwinder now becomes dependent on objtool's
ability to reverse engineer GCC code paths.  If GCC optimizations become
too complicated for objtool to follow, the orc data generation might
stop working or become incomplete.  (It's worth noting that livepatch
already has such a dependency on objtool's ability to follow GCC code
paths.)

If newer versions of GCC come up with some optimizations which break
objtool, we may need to revisit the current implementation.  Some
possible solutions would be asking GCC to make the optimizations more
palatable, or having objtool use DWARF as an additional input, or
creating a GCC plugin to assist objtool with its analysis.  But for now,
objtool follows GCC code quite well.


Unwinder implementation details
-------------------------------

Objtool generates the orc data by integrating with the compile-time
stack metadata validation feature, which is described in detail in
tools/objtool/Documentation/stack-validation.txt.  After analyzing all
the code paths of a .o file, it creates an array of orc structs, and a
parallel array of instruction addresses associated with those structs,
and writes them to the .orc_unwind and .orc_unwind_ip sections
respectively.

The orc data is split into the two arrays for performance reasons, to
make the searchable part of the data (.orc_unwind_ip) more compact.  The
arrays are sorted in parallel at boot time.

Performance is further improved by the use of a fast lookup table which
is created at runtime.  The fast lookup table associates a given address
with a range of orc unwind table indices, so that only a small subset of
the orc unwind table needs to be searched.


Etymology
---------

Orcs, fearsome creatures of medieval folklore, are natural enemies of
the Dwarves.  Similarly, the orc unwinder has been created in opposition
to DWARF.  Unlike the esoteric DWARF unwinder, the veracious orc
unwinder wastes no time or siloconic effort decoding variable-length
zero-extended unsigned-integer byte-coded state-machine-based debug
information entries.

The Orcs are not only opposed to Dwarves: they're adversarial toward
*all* beings -- sometimes even themselves.  This is not dissimilar to
the fact that the insular orc debuginfo format is exclusive to the Linux
kernel -- and may even have some bugs lurking which could harm the
kernel itself.  The orc debuginfo format is loathsomely feared by all
other software projects.

Similar to how Orcs frequently unravel the well-intentioned plans of
their adversaries, the orc unwinder frequently unravels stacks with
brutal, unyielding efficiency.


[1] https://lkml.kernel.org/r/20170602104048.jkkzssljsompjdwy@suse.de
[2] https://lkml.kernel.org/r/d2ca5435-6386-29b8-db87-7f227c2b713a@suse.cz
